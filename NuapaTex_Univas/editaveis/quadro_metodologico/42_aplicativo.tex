%\subsection{Aplicativo}

	\par Para iniciar a construção do aplicativo, fez-se necessário a instalação e
configuração do ambiente de desenvolvimento. Primeiramente, realizou-se o
\textit{download} da IDE Android Studio, versão 1.1.0 e do Android SDK, versão
24.0.2, ambos no site \textit{Developers} Android através do endereço
https://developer.android.com/intl/pt-br/sdk/index.html.

	\par Contudo, ao executar o emulador do Android o sistema apresentava a
seguinte mensagem: \textit{"emulator: Failed to open the HAX device!"}.
Depois de algum tempo pesquisando, percebeu-se que era necessário instalar um programa
chamado \textit{Intel Hardware Accelerated Execution Manager} (HAXM), que
permite a execução emulador Android mais rápido.

	\par No entanto, ao instalá-lo ocorria o seguinte erro:\textit{ “this computer
meets the requirements for haxm but intel virtualization technology (VT-x) is
not turned on”}.  A solução foi acessar a BIOS da máquina e habilitar o
assistente de hardware para virtualização. Daí em diante, foi possível executar
no emulador as aplicações feitas no Android Studio.

	\par Com o ambiente já configurado, foi criado um repositório no controlador de
versão Github, o qual pode ser acessado através do endereço
https://github.com/diegodnunes12/AppTCC e compartilhado entre os participantes
do projeto.

	\par A partir de então, passou-se a desenvolver o software. A princípio, foi
construída uma \texttt{activity}, que é acessível ao aluno logo que a aplicação
se inicia. Essa \texttt{activity} é do tipo Navigation Drawer Layout, ou seja,
é um painel que permite inserir as opções de navegação do aplicativo,
semelhante a um menu.

	\par Ao criar essa \texttt{activity}, o Android Studio gera automaticamente
a classe \texttt{NavigationDrawerFragment} e um arquivo XML na pasta
\textit{layout}, chamado \texttt{fragment\_navigation\_drawer.xml}.

	\par No arquivo \texttt{fragment\_navigation\_drawer.xml} foram inseridos três
\textit{widgets}, sendo dois do tipo \texttt{textView}, para o cabeçalho com a
logomarca da Univás e para o rodapé com o seguinte texto: “Univás – Pouso
Alegre – MG” e um \textit{widget} do tipo \texttt{listView} que contém a lista
com as opções que o software oferece ao aluno.

	\par O \textit{layout} desta \textit{activity} chama-se o
\texttt{relativeLayout}, o qual permite adicionar um elemento em relação ao
outro. Desta forma o \textit{widget} \texttt{listView} utiliza o comando
\texttt{android:layout\_below="@+id\/headerView} para se posicionar após o
componente com id \textit{headerView} e a instrução
\texttt{android:layout\_above="@+id\/footerView"} indicando que ela deve
preceder o \textit{widget} com id \textit{footerView}. Na Figura \ref{fig:app},
pode ser visto o código XML dos \textit{widgets} desta tela.

	\begin{figure}[h!] 
		\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app.png}}
		\caption[Código XML dos widgets do arquivo
		fragment\_navigation\_drawer.xml]{Código XML dos widgets do arquivo
		\texttt{fragment\_navigation\_drawer.xml}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:app}
	\end{figure}
	
	\pagebreak

	\par A classe \texttt{NavigationDrawerFragment} representa o painel de
navegação. Nela se destaca o método \texttt{onCreateView()}, responsável por
criar o \textit{layout} de navegação. Na Figura \ref{fig:app1}, vê-se o método
\texttt{onCreateView()} informando ao sistema operacional o \texttt{layout} a
ser chamado e adicionando a um \textit{array} de \textit{String} as
alternativas de navegação que serão exibidos no \textit{listView} da tela
principal.

	\begin{figure}[h!] 
		\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app1.png}}
		\caption[Método onCreateView()]{Método \texttt{onCreateView()}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:app1}
	\end{figure}
	
	\par O próximo passo foi criar o banco de dados do aplicativo para salvar as
informações recebidas do \textit{web service}. Para que isso fosse possível,
elaborou-se uma classe denominada \texttt{DatabaseHelper} que estende da classe
\texttt{SQLiteOpenHelper} do Android, com dois métodos, um chamado
\texttt{onCreate()} que cria a estrutura do banco de dados e outro conhecido
por \texttt{onUpgrade()}, usado se for necessário atualizar a estrutura do
banco de dados.

	\par Foi preciso criar um atributo que mantém a versão do banco de dados. Essa
informação serve para que o Android consiga saber qual dos dois métodos devem
ser executados. Ao iniciar a aplicação pela primeira vez, estando a versão em 1
(um), o sistema chamará o método \texttt{onCreate()}. Se for preciso atualizar
a estrutura do banco, o atributo versão deve ser incrementado em 1 (um), de
modo que ao executar o software o sistema operacional perceba a mudança,
chamando o método \texttt{onUpgrade()}. Na Figura \ref{fig:app2} é apresentado a
classe \texttt{DatabaseHelper}.

	\begin{figure}[h!] 
		\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app2.png}}
		\caption[Classe DatabaseHelper]{Classe \texttt{DatabaseHelper}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:app2}
	\end{figure}
	
	\pagebreak
	
	\par Em seguida foi criada a classe responsável por executar as consultas SQL,
denominada \texttt{DatabaseExecute}. Nela foram inseridos os métodos
responsáveis por inserir, alterar e buscar os dados dos alunos no banco de
dados local do aplicativo. Na Figura \ref{fig:app3}, pode se observar o método
que possibilita a inserção dos eventos ocorridos. Esses eventos podem ser notas,
faltas ou provas agendadas.

	\begin{figure}[h!] 
		\centerline{\includegraphics[scale=1]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app3.png}}
		\caption[Método de inserção de eventos]{Método de inserção de eventos.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:app3}
	\end{figure}
	
	\pagebreak
	
	\par Este método recebe um objeto da classe \texttt{EventTO} com os elementos
necessários para inserir o evento no banco de dados. Para que seja possível a
inserção dos dados, \citeonline{monteiro2012}, afirma que é necessário
recuperar a referência da classe \texttt{SQLiteDatabase} através do método
\texttt{getWritableDatabase()}, logo após é instanciada a classe
\texttt{ContentValues}, onde é informado o campo da tabela e o valor desejado.
Ao concluir, é chamado o \texttt{insert} da classe \texttt{SQLiteDatabase}
informando o nome da tabela e o objeto da classe \texttt{ContentValues}.

	\par Para listar os resultados dos exames realizados pelos discentes no painel
de notas é utilizado o método \texttt{getResults()} que retorna uma lista de
objetos da classe \texttt{EventTO}. De acordo com \citeonline{monteiro2012},
para conseguir recuperar as informações armazenadas no banco de dados é preciso
adquirir a instância de leitura da classe \texttt{SQLiteDatabase} através do
método \texttt{getReadableDatabase()}. Por meio dele pode-se realizar a
consulta, que devolve um \textit{Cursor} para navegar pelos resultados. Por
fim, é composto um objeto do tipo \texttt{EventTO} e inserido na lista. Na
Figura \ref{fig:app4} é apresentado o método \texttt{getResults()}.

	\begin{figure}[h!] 
		\centerline{\includegraphics[scale=0.65]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app4.png}}
		\caption[Método getResults()]{Método \texttt{getResults()}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:app4}
	\end{figure}
	
	\pagebreak
	
	\par Foram inseridos mais dois métodos semelhantes ao \texttt{getResults()},
chamados de \texttt{getFouls()} e \texttt{getAgendas()} para recuperar as
faltas e provas agendadas respectivamente. O que diferencia-os é a consulta
SQL, já que no \texttt{getFouls()} foram buscados os dados onde o tipo\_evento
= ‘FALTAS' e no \texttt{getAgendas()} onde o tipo\_evento = 'PROVA\_AGENDADA'.

	\par A fim de estabelecer uma conexão entre o aplicativo e o \textit{web
service} foi preciso conceder a permissão de acesso à internet no arquivo
\texttt{AndroidManifest.xml} da seguinte forma: \texttt{<uses-permission
android:name="android.permission.INTERNET" />}.

	\par Logo após, criou-se uma classe chamada de \texttt{HttpUtil} para ler
informações recebidas do \textit{web service}. Nela foram inseridos dois
métodos, sendo um chamado \texttt{getJsonDisciplinas()} para receber as
informações referentes as disciplinas cursadas e outro denominado
\texttt{getJsonEventos()} para captar os dados de eventos como notas, faltas e
provas agendadas.

	\par Os dois métodos são semelhantes, no entanto, o \texttt{getJsonEventos()}
recebe os dados e transforma-os em objetos da classe \texttt{EventTO} enquanto
o método \texttt{getJsonDisciplinas()} converte os elementos em objetos da
classe \texttt{DisciplineTO}. Na Figura \ref{fig:app5} é possível ver o método
\texttt{getJsonEventos()} incumbido de ler as informações de eventos.

	\begin{figure}[h!] 
		\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app5.png}}
		\caption[Método getJsonEventos()]{Método \texttt{getJsonEventos()}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:app5}
	\end{figure}
	
	\pagebreak
	
	\par Neste método foi preciso criar uma \textit{thread} separada da
\textit{thread} principal do sistema, evitando travar a aplicação enquanto
recebe as informações vindas do \textit{web service}. Estes dados estão em
formato JSON e foi utilizada a biblioteca Gson para convertê-las para o formato
da classe \texttt{EventTO}. Após a leitura, o objeto da classe \texttt{EventTO}
é enviado para a classe \texttt{DatabaseExecute}, a fim de realizar a inserção
os dados no banco.
	
	\par Para usufruir da biblioteca Gson, foi fundamental adicioná-la como uma
dependência do projeto. Para isso, foi preciso ir ao Menu do Android Studio,
clicando em \textbf{File} e depois em \textbf{Project Structure}. Com a janela
da estrutura do projeto aberta, foi selecionada a aba \textbf{Dependencies} e
depois foi escolhido o ícone de mais (+) para adicionar novas dependências,
conforme mostra a Figura \ref{fig:app6}.
	
	\begin{landscape}
	
		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app6.png}}
			\caption[Adicionando uma dependência ao projeto]{Adicionando uma dependência ao projeto.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app6}
		\end{figure}
	
	\pagebreak
	
	\end{landscape}
	
	\par Na tela em que foi aberta localizou-se a biblioteca Gson com o endereço da
Google, logo após selecionou-a e clicou no botão Ok para adicioná-la, como
mostra a Figura \ref{fig:app7}.
	
		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app7.png}}
			\caption[Adicionando a biblioteca Gson ao projeto]{Adicionando a biblioteca Gson ao projeto.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app7}
		\end{figure}

	\par Depois, fez-se necessário construir uma classe que faz a ligação e
organização dos dados vindos do banco de dados com a interface que listará as
informações ao usuários. Essa classe recebeu o nome de
\texttt{ListResultsAdapter} e estende da classe nativa do Android denominada
\texttt{BaseExpandableListAdapter}.

	\par Nesta classe foi criado um construtor que recebe a lista de disciplinas
cursadas pelo aluno e uma lista com as notas de cada matéria. O nome das
disciplinas foram inseridos em um \textit{array} de \textit{Strings}, já as
notas foram inseridas em uma matriz, como apresenta a Figura \ref{fig:app8}.


		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app8.png}}
			\caption[Construtor da classe ListResultsAdapter]{Construtor da classe
			\texttt{ListResultsAdapter}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app8}
		\end{figure}
	
	\pagebreak
	
	\par Após adicionado os dados no \textit{array} e na matriz é preciso exibí-los
ao estudante. Para realizar essa tarefa foi utilizado o método
\texttt{getGroupView()} para apresentar os nomes das disciplinas e o método
\texttt{getChildView()} para mostrar as notas de cada matéria.

	\par Na Figura \ref{fig:app9}, pode se ver o método \texttt{getGroupView()}
criando um \textit{widget} do tipo \textit{textView}  e inserindo nele o
nome da matéria, os espaçamentos, o tamanho da fonte e informando que as
palavras serão escritos em negrito.
	
		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app9.png}}
			\caption[Método getGroupView()]{Método \texttt{getGroupView()}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app9}
		\end{figure}
	
	\pagebreak
	
	\par O método \texttt{getChildView()} segue a mesma lógica do método
getGroupView(), como ilustra a Fugura \ref{fig:app10}.

		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app10.png}}
			\caption[Método getChildView()]{Método \texttt{getChildView()}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app10}
		\end{figure}
	
	\par O próximo passo, foi criação de uma \textit{activity} do tipo
\textit{blank activity} com finalidade de listar as notas. Ao criá-la com o
nome de \texttt{ListResultsActivity}, o Android Studio gerou dentro da pasta
\textit{layout} o arquivo XML referente a ela, chamado de
\texttt{activity\_list\_results.xml}. Neste, foi inserido apenas o
\textit{widget}  \texttt{expandableListView}, que está incumbido de apresentar
a lista de disciplinas cujo o discente está cursando e ao clicar em alguma
dessas matérias serão apresentadas as notas referentes aos exercícios
realizados desta disciplina. Na Figura \ref{fig:app11} é possível ver o código
XML de uma lista do tipo \texttt{expandableListView}.

		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app11.png}}
			\caption[Código XML do layout que apresentará a lista de notas]{Código XML
			do layout que apresentará a lista de notas.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app11}
		\end{figure}
	
	\pagebreak
	
	\par Na classe \texttt{ListResultsActivity}, é preciso informar ao sistema
operacional o \textit{layout} a ser chamado através do método
\texttt{setContentView()}. Também foi necessário passar para a classe
\texttt{ListResultsAdapter} a lista de disciplinas que o discente está cursando
e a lista com as notas referentes a cada matéria. Na Figura \ref{fig:app12} é exibido o
método \texttt{onCreate()} da classe \texttt{ListResultsActivity}.


		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app12.png}}
			\caption[Método onCreate() da classe ListResultsActivity]{Método \texttt{onCreate()} da classe
			\texttt{ListResultsActivity}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app12}
		\end{figure}
	
	\par Estes procedimentos realizados para as classes
\texttt{ListResultsActivity} e \texttt{ListResultsAdapter} foram necessários
para apresentar as notas dos exercícios resolvidos. Desta mesma forma foi
preciso criar uma \textit{activity} e um \textit{adapter} tanto para faltas
quanto para provas agendadas seguindo a mesma lógica.

	\par No momento em que algum professor lançar notas, faltas ou provas agendadas
no portal do aluno, é indispensável notificar ao estudante. Com esse intuito
desenvolveu-se uma classe chamada de \texttt{GcmIntentServiceUnivas} que
estende \texttt{IntentService}.

	\par Esta classe recebe os dados em formato JSON, por isso ela transfere estas
informações para o método \texttt{getJsonEventos()} da classe
\texttt{HttpUtil}, o qual será responsável por ler os dados e realizar os
procedimentos de gravação no banco de dados.

	\par Ao salvar o evento é chamado o método \texttt{sendNotification()}, que
receberá um objeto da classe \texttt{EventTO}. Ele realiza uma analise do tipo
de evento, para saber qual \textit{activity} deve ser executada quando o
usuário clicar na notificação. Logo após foi adicionado os atributos da
notificação, como o ícone, o título e a mensagem que irá aparecer ao usuário.
Na Figura \ref{fig:app13} é visível o método \texttt{sendNotification()}.


		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.55]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app13.png}}
			\caption[Método sendNotification()]{Método \texttt{sendNotification()}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app13}
		\end{figure}
	
	\pagebreak
	
	\par A notificação acontece toda vez que o GCM envia uma informação ao
dispositivo. Para tratar essas ocorrências foi projetada uma classe para ser o
\texttt{BroadcastReceiver} chamada de \texttt{GcmBroadcastReceiverUnivas}. Ela
estende da classe \texttt{WakefulBroadcastReceiver} nativa do Android e possui
apenas um método chamado de \texttt{onReceive()}, o qual receberá a
\textit{intent} a ser chamada quando chegar algum dado. Na Figura
\ref{fig:app14}, vê-se a classe \texttt{GcmBroadcastReceiverUnivas}, que
através do método \texttt{onReceive()} inicializará a classe
\texttt{GcmIntentServiceUnivas}.

		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app14.png}}
			\caption[Classe GcmBroadcastReceiverUnivas]{Classe \texttt{GcmBroadcastReceiverUnivas}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app14}
		\end{figure}
	
	\par No entanto para configurar esta classe como um \texttt{BroadcastReceiver},
foi preciso adicioná-la na \textit{tag} \texttt{<receiver>} do arquivo
\texttt{AndroidManifest.xml}, como mostra a Figura \ref{fig:app15}.

		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app15.png}}
			\caption[Configuração do BroadcastReceiver no
			AndroidManifest.xml]{Configuração do \texttt{BroadcastReceiver} no
			\texttt{AndroidManifest.xml}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app15}
		\end{figure}
	
	\par Por fim, foi construída uma classe chamada de \texttt{GcmControllerUnivas}
que tem por objetivo configurar o dispositivo para trabalhar com o GCM.

	\par Nesta classe existe um método denominado \texttt{checkPlayServices()} como
intuito de verificar se o dispositivo possui os requisitos necessários para o
GCM. Na Figura \ref{fig:app16}, é apresentado o método
\texttt{checkPlayServices()}.

		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app16.png}}
			\caption[Método checkPlayServices()]{Método \texttt{checkPlayServices()}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app16}
		\end{figure}
	
	\pagebreak
	
	\par Logo após é chamado o método \texttt{getRegistrationId()}, que é incumbido
de retornar o \textit{Registration ID}. Na Figura \ref{fig:app17} é possível ver
o método \texttt{getRegistrationId()}. No entanto, se o registro retornado for nulo,
isso significa que o aparelho não está cadastrado nos servidores da Google,
então é executado o método \texttt{registerInBackground()} que fará esse
cadastro, como demostra a Figura \ref{fig:app18}.

		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app17.png}}
			\caption[Método getRegistrationId()]{Método \texttt{getRegistrationId()}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app17}
		\end{figure}
	
		\begin{figure}[h!] 
			\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/42_aplicativo/app18.png}}
			\caption[Método registerInBackground()]{Método \texttt{registerInBackground()}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:app18}
		\end{figure}
	
	\par Desta forma, quando o \textit{web service} envia uma informação ao GCM, é
transmitido junto aos dados o \textit{Registration ID}, gerado pelo método
\texttt{registerInBackground()}, possibilitando ao serviço da Google identificar
a qual dispositivo deve conduzir a mensagem.
