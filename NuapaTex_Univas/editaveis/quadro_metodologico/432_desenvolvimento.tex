%\subsubsection{Desenvolvimento}

	\par Com o ambiente de desenvolvimento pronto, começou de fato o
desenvolvimento. Primeiramente foi necessário criar o banco de dados no SGDB.
Este por sua vez foi criado com a ajuda do PgAdmin que é um software gráfico
para administração do SGDB, e que fornece uma interface visual de apoio para o
PotgreSql. Para criar o banco era necessário ja estar com o PgAdmin aberto e
conectado a um servidor de banco de dados que neste caso era em servidor local como pode
ser visto na Figura \ref{fig:desws}.

	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.5]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws.png}}
		\caption[Servidor de banco de dados local no PgAdmin]{Servidor de banco de
		dados local no PgAdmin.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws}
	\end{figure}
	
	\par Para a efetiva criação do banco de dados era necessário clicar com o
botão direito do \textit{mouse}, sobre a opção \textbf{Databases -> New
Database\ldots} no PgAdmin, apresentada na Figura \ref{fig:desws1}.

	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.5]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws1.png}}
		\caption[Opção \textit{New Database\ldots}]{Opção \textit{New Database\ldots}.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws1}
	\end{figure}

	\pagebreak
	
	\par Em seguida foi necessário preencher o dados da janela apresentada, como
está apresentado na Figura \ref{fig:desws2}.
	
	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws2.png}}
		\caption[Tela \textit{New Database\ldots}]{Tela \textit{New Database\ldots}.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws2}
	\end{figure}

	\par Como pode ser visto foram preenchidos os campos \textbf{Name} e
\textbf{Owner}. O campo \textbf{Name} se refere ao nome do banco de dados que
foi definido com \texttt{wsappunivas}, e o campo \textbf{Owner}, o responsável
pelo banco de dados, que para este caso foi usuário padrão do SGDB, que é o
\texttt{postgres}. Além destas configurações mais nenhuma opção foi necessária.
O banco de dados foi criado, porém sua estrutura não está definida, pois como
será visto mais adiante o Hibernate, possui um mecanismo, que com algumas
configurações, permite a estruturação do banco de dados, de acordo com o
mapeamento objeto-relacional e de acordo com a evolução do projeto. Isto
permitirá mudanças na estrutura do banco de dados e suas tabelas, e até mesmo
eventuais correções, no decorrer do desenvolvimento da aplicação.
	
	%02 - Início do projeto web no eclipse;
	\par Em seguida foi criado um projeto do tipo Dynamic Web Project no
Eclipse conforme Apêndice I. Antes de começar o desenvolvimento foi necessário
ainda criar uma pasta a qual foi a responsável por conter todos os arquivos
\texttt{.jar} das bibliotecas que foram usadas para o desenvolvimento do
\textit{web service}. Em seguida foram copiados todos os arquivos \texttt{.jar}
da biblioteca Hibernate que eram necessários ao projeto, para dentro desta
pasta e também o \texttt{jar} do \textit{driver} JDBC do PostGreSql, que seria
responsável por fazer a comunicação entre o banco de dados e a aplicação.
	
	\par Além disso era necessário mais uma configuração para que as bibliotecas
pudessem ser reconhecidas como parte do projeto. Era necessário fazer a
inclusão destas bibliotecas para dentro do \textit{build path} do projeto. Para
isso foi necessário selecionar todos os arquivos \texttt{.jar} que estavam
dentro da pasta \texttt{libs}, clicar com o botão direito do mouse sobre eles e
escolher a opção \textbf{Build Path -> Add to Build Path}, que pode ser visto
na Figura \ref{fig:desws6_3}.

	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.60]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws6_3.png}}
		\caption[Tela para criação de um novo projeto no Eclipse]{Tela para criação de um novo projeto no Eclipse.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws6_3}
	\end{figure}
	
	\pagebreak
	
	\par Com o projeto devidamente configurado, começou-se de fato a desenvolver a
camada de persistência da aplicação. Para este propósito, primeiramente foi
criado um pacote, onde ficaram contidas as classes que representam as entidades
do ORM. Este pacote recebeu o nome de
\texttt{br.edu.univas.restapiappunivas.model},  pois nele estão contidas as
classes que fazem parte do modelo de negócios da aplicação. Este pacote foi
criado visando a divisão das responsabilidades internas no projeto, além de
contribuir positivamente com a organização do mesmo. 
	
	\par Com este pacote criado, ja era possível criar as classes do ORM. Foi
criada primeiramente a classe \texttt{Student.java}. Esta classe foi definida
para representar as informações referente aos alunos. O código fonte desta
classe pode ser visto na Figura \ref{fig:desws11}.
	
	
	\begin{figure}[h!]
		\input{code/student_java}
		\caption[Classe Student.java]{Classe \texttt{Student.java}.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws11}
	\end{figure}
	
	\pagebreak
	
	\par É válido lembrar que esta classe possui anotações para que possa ser
reconhecida como uma entidade do JPA, e assim persistida no banco de dados
quando necessário. Além disso estas anotações possuem outras finalidades
específicas. A seguir estão listadas todas as anotações  que foram usadas na
classe \texttt{Student.java} e nas outras classes que fazem parte do mapeamento
objeto relacional da aplicação e definidas suas funcionalidades.

	\begin{itemize}
	  \item \texttt{@Entity}: esta anotação foi necessária para que esta classe
	  pudesse ser reconhecida como uma entidade do JPA e assim persistida no banco
	  de dados;
	  \item \texttt{@Table}: anotação que possui algumas configurações relativas a
	  uma tabela no banco de dados, a qual esta entidade representa, no caso da
	  classe mostrada anteriormente é configurado o nome da tabela;
	  \item \texttt{@Id}: esta anotação fica sobre o atributo da entidades, o qual
	  representa a chave primária no banco de dados;
	  \item \texttt{@GeneratedValue}: esta anotação indica qual será a estratégia
	  usada para incrementar a chave primária da tabela.
	  \item \texttt{@SequenceGenerator}: esta anotação define o mecanismo com que
	  a chave primária será incrementada.
	  \item \texttt{@Column}: define algumas propriedades do campo da tabela do
	  banco de dados, o qual o atributo que ele anota representa. Estas
	  configuraçãoes podem são:
		  	\begin{itemize}
		    	\item \texttt{name}: mapeia o nome do campo;
		    	\item \texttt{length}: determina o tamanho em caracteres que o campo
		    	aceitará;
		    	\item \texttt{nullable}: define se o preenchimento do campo é obrigatório;
		    	\item \texttt{unique}: este atributo define se o campo aceitará valores
		    	únicos;
		    \end{itemize}
	  \item \texttt{@OneToMany}: representa um relacionamento um-para-muitos no
	  banco de dados. Anotam coleções de outras entidades as quais esta entidade
	  possui relacionamento;
	  \item \texttt{@ManyToOne}: representa um relacionamento
	  muitos-para-um no banco de dados. Este é a contraparte da anotação
	  um-para-muitos;
	  \item \texttt{@OneToOne}: representa um relacionamento um-para-um no banco de
	  dados.
\end{itemize}
 
	\par Esta classe faz parte do mecanismo de persistência de dados e é
simplesmente um  POJO ou seja, um objeto  simples que contêm somente atributos
privados e os métodos \textit{getters} e \textit{setters} que servem apenas
para encapsular estes atributos, e não possue nenhuma lógica de negócios. Além
desta classe, foram criadas outras com os mesmos propósitos, que podem ser
vista no diagrama de classes que esta apresentado na Figura \ref{fig:desws12}.
	
	
	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.55]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/diagrama.png}}
		\caption[Modelo fisíco do banco de dados]{Modelo fisíco do banco de dados.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws12}
	\end{figure}
	
	\pagebreak
	
	\par Estas classes tinham a mesma finalidade da anterior, porém com pequenas
diferenças no que diz respeito aos atributos, metodos e anotações. Estas classes
representam, de maneira individual, as tabelas no banco de dados. O modelo
fisíco do banco de dados pode ser visto na Figura \ref{fig:desws12_1}.
	
	
	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.55]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/mer_ws.pdf}}
		\caption[Modelo fisíco do banco de dados]{Modelo fisíco do banco de dados.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws12_1}
	\end{figure}
	
	\pagebreak

	\par E por fim, para cada classe que representa uma entidade, foi necessário
implementar os métodos \texttt{hashCode()} e \texttt{equals()}, para que estas
pudessem facilmente ser comparadas e diferenciadas em relação aos seus valores,
haja vista que cada instância destas classes representa um registro no banco de
dados. A própria IDE provê uma forma fácil para criar este métodos, bastando
para isso clicar com o botão direito do mouse sobre o código da classe e
escolher a opção \textbf{Source -> Generate hashCode() and equals()\ldots} como
pode ser visto na Figura \ref{fig:desws13}.

	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws13.png}}
		\caption[Opção Generate hashCode() and equals()\ldots]{Opção Generate
		hashCode() and equals()\ldots .
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws13}
	\end{figure}
	
	\par Os métodos \texttt{hashCode()} e \texttt{equals()} da classe
\texttt{Student.java} foram implementados\\ usando o atributo \texttt{idStudent}
e podem ser vistos na Figura \ref{fig:desws15}.

	\begin{figure}[h!]
		\input{code/hash}
		\caption[Implementação os métodos hashCode() e equals()]{Implementação os
		métodos \texttt{hashCode()} e \texttt{equals()}.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws15}
	\end{figure}
	
	\pagebreak
	
	
	\par Além destas classes, foi necessário criar um tipo enumerado (ou enum),
para definir quais seriam os tipos dos eventos, haja vista que estes teriam um
numero limitado de possibilidades. Para esta enumeração foi definido o nome
\texttt{EventType}. Os tipos de eventos definidos foram três:

	\begin{itemize}
	  \item \texttt{PROVA\_AGENDADA}: que define um evento como agendamento de uma
	  atividade avaliativa;
	  \item \texttt{PROVA\_APLICADA}: que define um evento como, a efetiva
	  realização de uma atividade avaliativa;
	  \item \texttt{FALTAS}: representa o lançamento de faltas;
	\end{itemize}
	
	\par A implementação da enumeração pode ser vista na Figura \ref{fig:desws15}.

	\begin{figure}[h!]
		\input{code/event_type}
		\caption[Implementação os métodos hashCode() e equals()]{Implementação os
		métodos \texttt{hashCode()} e \texttt{equals()}.
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws15}
	\end{figure}

	\par Após a criação das entidades, foi necessário configurar o arquivo
\texttt{persistence.xml}. Foi necessário criar a pasta META-INF dentro da pasta
de de códigos fontes do projeto que também é conhecida como \textit{classpath},
com a finalidade de abrigar este arquivo. Em seguida foi criado o arquivo
dentro desta pasta. 

	\par O arquivo \texttt{persistence.xml} é extremamente importante, pois é nele
que estão todas as configurações relativas à conexão com o banco de dados,
configurações referentes ao Dialeto SQL que vai ser usado para as consultas e
configurações referentes ao \textit{persistence unit} que é o conjunto de
classes mapeadas para o banco de dados. Este por sua vez recebeu o nome de
\texttt{WsAppUnivas}. 
	\par Uma das configurações do \texttt{persistence.xml}, merece uma atenção
especial. Trata-se da configuração \texttt{<property
name="hibernate.hbm2ddl.auto" value="create" />} que é a responsável por
definir que o próprio Hibernate irá criar a estrutura do banco de dados
(tabelas, sequences, etc.) através do mapeamento objeto relacional das classes.
O arquivo \texttt{persistence.xml} está exposto na Figura \ref{fig:desws16}.

	\begin{figure}[h!]
		\input{code/persistence_xml}
		\caption[Arquivo \texttt{persistence.xml}]{Arquivo \texttt{persistence.xml}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws16}
	\end{figure}
	
	\pagebreak
	
	\par Em seguida à confecção do \texttt{persistence.xml} foi criada a
classe \texttt{JpaUtil.java} que está representada na Figura \ref{fig:desws17}.
Para isso foi necessário criar um pacote que seria responsável por armazená-la,
para que a organização do projeto pudesse ser mantida. Tal pacote recebeu o nome de
de \texttt{br.edu.univas.restapiappunivas.util} e poderia se neceessário
abrigar outras classes de utilidades do projeto assim como a classe
\texttt{JpaUtil.java}.
	
	\par A classe \texttt{JpaUtil.java} é responsável por criar uma
\texttt{EntityManagerFactory}. Este por sua vez é uma  fábrica de instâncias de
\texttt{EntityManager} que é quem cria a \textit{persistence unit} ou unidade
de persistência. O \textit{persistence unit} desta aplicação foi configurado
através do arquivo \texttt{persistence.xml}. Este por sua vez tem a
responsabilidade de prover um modo de comunicação entre a aplicação e o banco
de dados. No entanto a classe \texttt{JpaUtil.java} cria uma única instância de
\texttt{EntityManagerFactory}, que é responsável por disponibilizar e gerenciar
as instâncias de \texttt{EntityManager} de acordo com a necessidade da
aplicação.
	
	\begin{figure}[h!]
		\input{code/jpaUtil}
		\caption[Classe \texttt{JpaUtil.java}]{Classe \texttt{JpaUtil.java}.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws17}
	\end{figure}

	\pagebreak
	
	\par Depois de finalizada a criação da camada de persistência do projeto foi
necessário uma configuração adicional. Percebeu-se que além das bibliotecas já
usadas no projeto, seriam necessárias mais algumas bibliotecas para que se
pudesse chegar ao resultado final esperado. Por esse motivo tornava-se inviável
ficar controlando as bibliotecas de maneira manual no projeto. Foi necessário
então, fazer a conversão do projeto para um projeto que fosse controlado pelo
Maven. Para tanto foi necessário clicar com o botão direito do mouse sobre o
projeto e navegar até a opção \textbf{Configure -> Convert to Maven Project},
como pode ser visto na Figura \ref{fig:desws18}

	\begin{figure}[h!]
		\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws18.png}}
		\caption[Opção Generate hashCode() and equals()\ldots]{Opção Generate
		hashCode() and equals()\ldots .
			\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws18}
	\end{figure}
	
	\par Na janela que foi apresentada na sequência, foi necessário preencher os
campos \textbf{Group id}, \textbf{Artifact id}, \textbf{Version} e
\textbf{Packaging}, da seguinte forma:

	\begin{itemize}
	  \item \textbf{Group id:} representa id do grupo a qual pertence o projeto,
	  que recebeu o nome de "\texttt{br.edu.univas}".
	  \item \textbf{Artifact id:} foi preenchido com o nome do próprio projeto já
	  criado anteriormente pois, este seria o nome do artefato final do gerado pelo
	  projeto.
	  \item \textbf{Version:} versão a qual está o projeto. Neste caso manteve-se
	  o que já veio por padrão.
	  \item \textbf{Packaging:} a forma como o projeto seria empacotado após a
	  compilação do mesmo. Foi escolhido ao empacotamento do tipo \texttt{war} por
	  se tratar de um projeto Java para \textit{web}.
	\end{itemize}
		
	\par Com a conclusão da conversão do projeto, foi gerado o arquivo
\texttt{pom.xml}. Este arquivo provê as informações necessárias para que o Maven
faça a gerência do projeto. Este arquivo possui, além das informações
apresentadas anteriormente (\textbf{Group id}, \textbf{Artifact id},
\textbf{Version} e \textbf{Packaging}), algumas informações a respeito da
compilação do projeto e o principal que é a gerência das dependências do
projeto. Inicialmente foi incluída somente as dependências referentes ao
\textit{driver} JDBC do PostGreSql e a biblioteca Hibernate como pode ser visto
na Figura \ref{fig:desws18}.
	
	\begin{figure}[h!]
		\input{code/pom_xml}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws18}
	\end{figure}

	\pagebreak
	
	\par Em seguida a essa configuração foi necessário apagar a pasta \texttt{libs}
do projeto, pois esta já não era mais necessária, haja vista que as bibliotecas
usadas no projeto já estavam sendo gerenciadas pelo Maven. A partir daí foi
necessário criar a parte de disponibilização dos serviços REST. Para isto foram
criados três novos pacotes para abrigar as classes que formaram a parte de
serviços do \textit{web service}, são eles:
	
	\begin{itemize}
	  \item \texttt{br.edu.univas.restapiappunivas.controllers}: pacote responsável
	  por agrupar as classes responsaveis por realizar as consultas na camada de
	  persistência do projeto e prover o resultados para publicação nos serviços.
	  \item \texttt{br.edu.univas.restapiappunivas.entities}: pacote responsável
	  por agrupar as classes que serviriam para abrigar os dados retonados nas
	  consultas dos \textit{controllers} e servir como retorno aos métodos das
	  classes de serviços.
	  \item \texttt{br.edu.univas.restapiappunivas.resources}: pacote responsável
	  por agrupar as classes responsaveis por prover os serviços REST.
	\end{itemize}


	\par Foi necessário criar algumas classes que eram responsáveis por fazer as
consultas no banco de dados usando o Hibernate. Estas classes tinham alguns
métodos que tinham a responsabilidade de fazer a consulta e retornar os dados
que seriam usados pelas classes que iam tornar disponíveis os serviços do
\textit{web service}. Uma destas classes é a \texttt{StudentEventsCtrl.java},
que pode ser vista na Figura \ref{fig:desws19}.
	
	\begin{figure}[h!]
		\input{code/student_event_ctrl}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws19}
	\end{figure}

	\pagebreak
	
	\par Esta classe é composta unicamente pelo método
\texttt{getEventsByRegistration()} o qual era responsável por fazer a busca de
todos os eventos de um determinado aluno pela sua matrícula. Ainda na Figura
\ref{fig:desws19} é perceptível que dentro deste método são usadas instancias
das classes \texttt{StudentEvent} e \texttt{StudentEvents}. A classe
\texttt{StudentEvent} foi criada apenas para servir como como um simples POJO
que conteria os retorno da consulta JPQL\footnote{JPQL - \textit{Java
Persistence Query Language}}. O código desta classe pode ser visto na Figura
\ref{fig:desws20}.
	
	\begin{figure}[h!]
		\input{code/student_event}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws20}
	\end{figure}

	\pagebreak

	\par Por outro lado a classe \texttt{StudentEvents} recebe uma coleção de
\texttt{StudentEvent} para que a mesma pudesse ser convertida corretamente para
JSON, nas classes que disponibilizam o serviço. O código fonte desta classe pode
ser visto na Figura \ref{fig:desws21}.
	
	\begin{figure}[h!]
		\input{code/student_events}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws21}
	\end{figure}
	
	\par Estas duas classes mostradas nas Figuras \ref{fig:desws20} e 
\ref{fig:desws21} foram criadas dentro do pacote\\ 
\texttt{br.edu.univas.restapiappunivas.entities}. Além delas foi criada também
a classe \texttt{StudentDiscipline} no mesmo pacote. Esta classe foi usada com o
mesmo propósito da \texttt{StudentEvents}, que era encpsular um resultado e
posterior conversão para JSON. O código fonte desta classe pode ser visto na
Figura \ref{fig:desws22}.

	\begin{figure}[h!]
		\input{code/student_disciplines}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws22}
	\end{figure}
	
	\par Ainda foi criada mais uma classe que tinha basicamente a mesma função da
classe \texttt{StudentEventsCtrl.java} que era de fazer a consulta e retornar
os dados que seriam usados pelas classes que iam tornar disponíveis os serviços
do \textit{web service}. Esta classe foi chmada de
\texttt{StudentDisciplinesCtrl.java} e seu código fonte pode ser visto na
Figura \ref{fig:desws23}.

	\begin{figure}[h!]
		\input{code/student_disciplines_ctrl}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws23}
	\end{figure}
	
	\par Em seguida à construção das classes que fazem a busca e retorno dos dados
na camada de persistência, foi desenvolvido a parte de disponibilização de
serviços \textit{RESTful}, fazendo uso do \textit{framework} Jersey em sua
versão de numero {1.19}. Para isso primeiramente foi necessário incluir no
arquivo \texttt{pom.xml}, a dependência referente ao \texttt{framework} Jersey
no arquivo \texttt{pom.xml} como pode ser visto na Figura \ref{fig:desws24}.

	\begin{figure}[h!]
		\input{code/pom_xml}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws24}
	\end{figure}
	
	\pagebreak

	\par Além desta configuração outras foram necessárias. Foi necessário apontar
no arquivo \texttt{web.xml} da aplicação, que pode ser encontardo dentro da
pasta \texttt{WebContent -> WEB-INF} do projeto, qual seria o \textit{servlet}
que seria responsável por prover os serviços, que para esta aplicação foi a
classe \texttt{com.sun.jersey.spi.container.servlet.ServletContainer}. Mais uma
configuração foi acrescentada no \textit{web.xml}, que foi a definição de em
que pacotes se encontrariam as classes que representam os serviços REST da
aplicação, que no caso foi o pacote
\texttt{br.edu.univas.restapiappunivas.resources}. Estas duas configurações
podem ser vistas na Figura \ref{fig:desws25}.

	\begin{figure}[h!]
		\input{code/web_xml_jersey}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws25}
	\end{figure}
	
	\par Com isso pode-se construir as classes que representam de fato os serviços
do \textit{web service}, que são as classes \texttt{StudentResouce.java} e
\texttt{UserResource.java}. Estas classes representam contextos REST desta
aplicação que segundo \citeonline[p.6]{saudate2012}, são "a raiz pela qual a
aplicação está sendo fornecida para o cliente". Dentro de um contexto pode haver
inumeros recursos que ainda segundo \citeonline[p.5]{saudate2012} podem ser
definidos como "conjuntos de dados que são trafegados pelo protocolo".

	\par Inicialmente foi contruída a classe \texttt{StudentResouce.java}, que
representa o contexto \texttt{students} desta aplicação. Esta classe está
representada na Figura \ref{fig:desws24}.

	\begin{figure}[h!]
		\input{code/students_resouces}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws24}
	\end{figure}
		
	\par A classe \texttt{StudentResouce.java}, representa o contexto
\texttt{Students}, e possui dois métodos que representam recursos REST. O
primeiro deles é \texttt{getEventsByStudentRegistration()} que representa o
recurso \texttt{events} e faz o retorno de todos o eventos de um determinado
aluno através de sua matrícula. Já o método
\texttt{getDisciplinesByStudentRegistration()} representa o recurso
\texttt{disciplines} tem por responsabilidade de retornar todas as disciplinas
cursadas por um aluno em determinado periodo. A url para acessar o método
\texttt{getEventsByStudentRegistration()} usando REST ficaria da seguinte
forma:\\
\url{http://localhost:8080/WebServiceAppUnivas/students/events/{registration}}
	
	\par Esta pode ser dividida da seguinte forma:

	\begin{itemize}
	  \item http:// : mostra qual protocolo está sendo usado para troca de
	  mensagenes que no caso é o HTTP;
	  \item localhost:8080 : indica o endereço e porta do servidor que fornece este
	  serviço;
	  \item WebServiceAppUnivas: representa o contexto universal da aplicação; 
	  \item students :representa um contexto específico dentro da aplicação;
	  \item events : representa um recurso;
	  \item registration: representa um parametro passado para o serviço;
	\end{itemize}

	\par Além da classe \texttt{StudentResouce.java}, foi desenvolvida
a classe também a classe \texttt{UserResources.java}. Esta por sua vez
represente o serviço mais importante do \textit{web service} que é responsável
por receber os \texttt{registration\_id} do dispositivo gerado pelo GCM. Sem
este não é possível enviar as mensagens aos servidores do GCM e
consequentemente não seria possível manter os aplicativos  dos alunos
constantemente atualizados. ò código fonte desta classe
	
	\par Era necessário também, que a cada novo evento lançado no banco de dados do
\textit{web service}, estes eventos fossem enviados ao GCM para que este pudesse
comunicar aos dispositivos dos alunos. Com a finalidade de sanar esta
necessidade foram construídas três classes, que eram responsáveis por tratar as
mensagens a serem enviadas e posteriormente enviá-las ao GCM. Estas classes
ficaram contidas no pacote \texttt{br.edu.univas.restapiappunivas.gcm}. 



	\par A primeira classe a ser criada foi \texttt{ContentMessageGCM.java}. Esta
classe tinha por finalidade estruturar o conteúdo da mensagem que seria
entregue ao GCM. Dentre os conteúdos da mensagem estão os
\texttt{registration\_ids}, que são os id's dos dispositivos dos alunos, que
foram registrados nos servidores do GCM e \texttt{data} que é o conteúdo da
mensagem. O código fonte desta classe pode ser visto na Figura
\ref{fig:desws30}.

	\begin{figure}[h!]
		\input{code/ContentMessageGCM}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws30}
	\end{figure}

	
	\par Além disso foi criada a classe estática \texttt{PostToGCM.java}, a qual
foi responsável por, converter o conteúdo da menssagem para o formato aceito
pelo GCM e enviá-lo através do método POST do HTTP. Para que a mensagem pudesse
ser convertida em JSON um objeto do tipo \texttt{ObjectMapper} foi usado, e
para enviar a mensagem para o GCM é usado um objeto do tipo
\texttt{HttpURLConnection}, em conjunto com o \texttt{ObjectMapper}. Esta classe
está apresentada na Figura \ref{fig:desws31}.

	\begin{figure}[h!]
		\input{code/PostToGCM}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws31}
	\end{figure}
	
	\pagebreak
	
	\par Além disso esta classe coleta a resposta retornada pelo GCM e lança este
retorno nos \textit{log's} da aplicação. E por fim para que estas duas classes
pudessem trabalhar conjuntamente foi necessário necessário criar a classe
\texttt{SendMessageGCM.java} que foi responsável por receber o conteúdo a ser
enviado e os ids dos dispositivos aos quais seriam enviadas estas mensagens, e
invocar o método \texttt{post()} da classe \texttt{PostToGCM.java} para que os
mesmos pudessem ser enviados. Foi nessa classe também que estava contida a
chave de autorização de envio de mensagens ao GCM, que foi atribuída ao
atributo \texttt{apiKey}. Esta classe pode ser vista na Figura
\ref{fig:desws32}.

	\begin{figure}[h!]
		\input{code/SendMessageGCM}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws32}
	\end{figure}
		
	\par Era necessário também que  de tempos em tempos o próprio \textit{web
service} fizesse uma varredura, buscando por novos eventos lançados para os
alunos, para que as classes reponsáveis por enviar as mensagens ao GCM, pudessem
enviar tais notificações. Para isto primeiramente foi criada a classe
\texttt{ListenerAtualizations.java} que pode ser vista na Figura
\ref{fig:desws33}.

	\begin{figure}[h!]
		\input{code/ListenerAtualizations}
		\caption[Arquivo \texttt{pom.xml}]{Arquivo pom.xml.
		\textbf{Fonte:}Elaborado pelos autores.}
		\label{fig:desws33}
	\end{figure}

	\par Para que esta classe pudesse funcionar

	\par Para que fosse possível transmitir dados para o aplicativo, era
necessário receber as informações do sistema acadêmico da referida instituição,
haja vista que o \textit{web service} é independente do mesmo. Para esse
propósito é necessário um módulo que faça a importação dos dados necessários
para a base de dados do \textit{web service}.

	\par Este por sua vez terá a responsabilidade de fazer a importação dos dados
periodicamente, e ainda tratar os tipos de dados recebidos para tipos
aplicáveis ao banco de dados local. Além disso é preciso notificar o módulo
responsável por invocar o serviço Google Cloud Messaging para que os
dispositivos dos alunos aos quais houveram atualizações nos dados, fossem
notificados e fizessem acesso ao \textit{web service} para solicitar esses
dados atualizados. Para esta pesquisa o módulo foi simulado.

	\par Os procedimentos acima citados foram os passos até agora realizados com o
propósito de se alcançar os resultados esperados para essa pesquisa.

