%\subsubsection{Desenvolvimento}

	%01 - Criação do database
	
	\par Com o ambiente de desenvolvimento pronto, podia-se começar de fato a
desenvolver. Primeiramente foi necessário criar o banco dedados no SGDB. O
banco foi criado, porém sua estrutura não foi definida, pois como será
visto mais adiante o \textit{Hibernate}, possui um mecanismo, que com algumas
configurações, permite a estruturação do banco de dados, de acordo com o
mapeamento objeto relacional. Isto permitirá mudanças na estrutura do banco de
dados e suas tabelas, e até mesmo eventuais correções.

	%02 - Início do projeto web com maven no eclipse;

	\par Em seguida foi criado um projeto do tipo \textit{web} no \textit{Eclipse}
com a ajuda do plugin \textit{Maven}. O \textit{archetype} usado foi
\textit{Quick Star WebApp}. Esse Projeto foi criado usando o \textit{Maven}
pois depende de uma quantidade considerável de \textit{frameworks}, e uma das
principais funcionalidades deste plugin, é ajudar na resolução das dependências
de um projeto Java.

	\par Para tal projeto foi necessário a configuração do \texttt{POM.xml} que é o
arquivo utilizado pelo \textit{Maven}. Nele estão contidas as configurações
relativas à compilação do projeto bem como suas dependências.  Na figura
\ref{fig:desws} a seguir pode ser visto o conteúdo do arquivo
\texttt{POM.xml}.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws.png}}
	\caption[\texttt{pom.xml}]{\texttt{pom.xml}.
		\textbf{Fonte:}Elaborado pelos autores.}
	\label{fig:desws}
\end{figure}

	%03 - Mapeamento orm;
	
		%	->Criação do pacote

	\par Com a estrutura do projeto devidamente criada foi possível iniciar os
trabalhos com a \\ camada de persistência de dados do projeto. Para este
propósito, primeiramente foi criado um pacote, onde ficaram contidas as classes
que representam as entidades do ORM. O pacote recebeu o nome de
"\texttt{br.edu.univas.restapiappunivas.model}", pois nele estão contidas as
classes que fazem parte do modelo de negócios da aplicação. Este pacote foi
criado visando a divisão das responsabilidades internas no projeto, além de
contribuir positivamente com a organização do mesmo. Tal pacote e as classes
que o compõe estão representandos na figura \ref{fig:desws1}.

\begin{figure}[h!]
	\centerline{\includegraphics[scale=0.8]{./imagens/2_q_metodologico/4_procedimentos_resultados/43_webservice/432_desenvolvimento/desws.png}}
	\caption[Estrutura do Projeto]{Estrutura do Projeto.
		\textbf{Fonte:}Elaborado pelos autores.}
	\label{fig:desws1}
\end{figure}
		
		%	->Criação das classes
	\par Com este pacote criado, ja era possível criar as classes do ORM. Foi
criada primeiramente a classe \texttt{Student.java}. Para que esta classe
pudesse ser reconhecida como um entidade e persistida ao banco de dados através
do \textit{Hibernate}, é necessário que esta classe tivesse a anotação
\texttt{@Entity}. Com isso esta classe ja poderia ser entendida como uma
entidade e poderia ser persistida no banco de dados, porém além dessa anotação
outras foram usadas para que a persistência pudesse ocorrer de forma
consistente.





	
	
			
	
		\par Fazendo uso desse diagrama foi possível criar todas as classes 
	\textit{Java} que representam as entidades do mapeamento objeto-relacional. 
	Essas classes foram criadas fazendo uso de anotações próprias do
	\textit{Hibernate}, que é um \textit{framework} que implementa a especificação
	JPA\footnote{JPA - \textit{Java Persistense API}}. Essas classes fazem parte
	dos mecanismos de persistêcia de dados e são simplesmente t ou seja, objetos
	simples que contêm somente atributos privados e os métodos \textit{getters} e
	\textit{setters} que servem apenas para encapsular estes atributos. Uma das
	classes criadas, foi a classe \texttt{Aluno.java} que representa a tabela
	\texttt{alunos} no banco de dados e está representada.
		
		\par Foram criadas outras classes \textit{Java} com a mesma finalidade da
	anterior, porém com pequenas diferenças no que diz respeito à atributos,
	metodos e anotações. Estas classes representam, de maneira individual, as
	tabelas no banco de dados. Certos atributos dessas classes têm por finalidade
	representar as colunas de cada tabela. Já os atributos que armazenam instâncias
	de outras classes ou até mesmo conjuntos (coleções) de instâncias representam os
	relacionamentos entre as tabelas. 
	
		%04 - HashCode e equals
		\par E por fim, para cada classe querepresenta uma 	entidade, foi necessário
	implementar os métodos \texttt{hashCode} e \texttt{equals}, para que estas
	pudessem facilmente ser comparadas e diferenciadas em relação aos seus
	valores, haja visto que cada instância destas classes representa um registro
	no banco de dados.
		
		%05 - Configuração do persistence.xml
		\par Em seguida à criação das entidades, foi necessário configurar o arquivo
	\texttt{persistence.xml} que fica dentro do \textit{classpath} do projeto
	\textit{Java} ou seja, dentro da mesma pasta onde estão contidos pacotes do
	projeto. Este arquivo é extremamente importante, pois é nele que estão todas
	as configurações relativas à conexão com o banco de dados, configurações
	referentes ao Dialeto SQL que vai ser usado para as consultas e configurações
	referentes ao \textit{persistence unit} que é o conjunto de classes mapeadas
	para o banco de dados.	O arquivo \texttt{persistence.xml} está exposto no
	código \ref{fig:qm11}.
	
 		\begin{figure}[h!]
			\centerline{\includegraphics[scale=0.6]{./imagens/2_q_metodologico/qm11.png}}
			\caption[Arquivo \texttt{persistence.xml}]{Arquivo \texttt{persistence.xml}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:qm11}
		\end{figure}
		
			%06 - Confecção JpaUtil.java
			\par Em seguida à confecção do \texttt{persistence.xml} foi criada a
		classe \texttt{JpaUtil} que está representada na Figura \ref{fig:qm12}.
		Esta classe é responsável por criar uma \texttt{EntityManagerFactory} que é
		uma  fábrica de instâncias de \texttt{EntityManager} que nada mais é que um
		\textit{persistence unit} ou unidade de persistência. Essa classe tem a
		responsabilidade de prover um modo de comunicação entre a aplicação e o banco
		de dados. No entanto a classe \texttt{JpaUtil} cria uma única instância de
		\texttt{EntityManagerFactory}, que é responsável por disponibilizar e
		gerenciar as instâncias de \texttt{EntityManager} de acordo com a necessidade
		da aplicação.
		
		\pagebreak
		\begin{figure}[h!]
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/qm12.png}}
			\caption[Classe \texttt{JpaUtil}]{Classe \texttt{JpaUtil}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:qm12}
		\end{figure}
		
	\par Em seguida à construção das classes que fazem a parte da persistência de
dados, foi desenvolvido a parte de disponibilização de serviços
\textit{RESTful}, fazendo uso do \textit{framework} \textit{Jersey}. Com isso
pode-se construir a classe que representa o primeiro serviço do
\textit{webservice}, que é a classe \texttt{Alunos}. Essa classe representa um
contexto REST, e portanto, dispõe de alguns recursos. Esses recursos fazem a
recuperação e a transmissão dos dados do \textit{webservice} para o aplicativo
\textit{Android}. Essa classe e seus respectivos métodos  estão representada na
Figura \ref{fig:qm13}.

		\begin{figure}[h!]
			\centerline{\includegraphics[scale=0.7]{./imagens/2_q_metodologico/qm13.png}}
			\caption[Classe \texttt{AlunosService}]{Classe \texttt{AlunosService}.
			\textbf{Fonte:}Elaborado pelos autores.}
			\label{fig:qm13}
		\end{figure}
		
		\par O \textit{webservice} pode fazer a busca de alunos pelo \texttt{id}
passado ou retornar uma coleção de eventos vinculados a um alunos, dependendo
do recurso acessado. Os tipos de dados que o \textit{webservice} consome e
retorna é o JSON\footnote{JSON - \textit{Javascript Object Notation}}. Não foi
necessário fazer nenhuma implementação adicional relativa a este formato, pois
o próprio \textit{framework Jersey} faz o tratamento e a conversão dos tipos de
entrada e saída de dados. No caso do saída de dados, faz a conversão de objetos 
\textit{Java} para JSON. E no caso de entrada tranforma um JSON em objeto
\textit{Java} já conhecido pelo \textit{webservice}. Com isso concluiu-se o
desenvolvimento do \textit{webservice} que fornece os dados para o aplicativo.

	%23 - Módulo que ira fazer a busca dos dados na base da instituição de ensino
	%24 - Falar que vai ser simulado
	\par Para que fosse possível transmitir dados para o aplicativo, era
necessário receber as informações do sistema acadêmico da referida instituição,
haja vista que o \textit{web service} é independente do mesmo. Para esse
propósito é necessário  contruir um módulo que faça a importação dos dados
necessários para a base de dados do \textit{web service}. 

	\par Este por sua vez terá a responsabilidade de fazer a importação dos dados
periodicamente, e ainda tratar os tipos de dados recebidos para tipos
aplicáveis ao banco de dados local. Além disso é preciso notificar o módulo
responsável por invocar o serviço \textit{Google Cloud Messaging} para que os
dispositivos dos alunos aos quais houveram atualizações nos dados, fossem
notificados e fizessem acesso ao \textit{web service} para solicitar esses
dados atualizados.

	\par Os procedimentos acima citados foram os passos até agora realizados com o
propósito de se alcançar os resultados esperados para essa pesquisa.



%07 - Explicar anotações dos pojos
%08 - Finalizando camada de persistência
%09 - Camada de serviço
%10 - Classes que disponibilizam serviços anotações
%11 - Explicar as entities criadas para disponibilizar os dados
%12 - Ctrls que fazem a busca dos dados
%13 - Problema do erro 500
%14 - Provedor de arquivos e contexto
%15 - Em todos citar o pom.xml
%16 - Configuração do web.xml
%17 - Módulo de varredura de atualizações com timerTask
%18 - Módulo de alerta de provas agendas no dia da prova
%19 - Configuração da conta no gcm
%20 - Módulo para disparar as mensagens para o gcm
%21 - Mostrar a estrutura do empacotamento depois de finalizado
%22 - Serviço que faz o registro de sender_id